# -*- coding: utf-8 -*-
"""Canalada.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WDRoqYXxrnKTScokm5P5t9GF2zkrbNu1

# **Program #1**
"""

#Program #1 (a)

import time

print("___________Greedy List Sorted__________")

class MakingChange:
    def __init__(self):
        # Hardcoded denominations
        self.denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]

    def make_change(self, amount):
        change = {}
        for coin in self.denominations:
            if amount >= coin:
                count = int(amount // coin)
                change[coin] = count
                amount = round(amount - (coin * count), 2)
        return change

# Directly instantiate MakingChange instead of using a factory
change_maker = MakingChange()

# Define test cases
test_cases = [1.25, 8.72, 12.35]

# Run each test case and measure execution time
for amount_to_change in test_cases:
    start_time = time.perf_counter()  # Start timing with high precision
    result = change_maker.make_change(amount_to_change)
    end_time = time.perf_counter()    # End timing with high precision
    execution_time = end_time - start_time

    print(f"Change for {amount_to_change} is:", flush=True)
    for coin, count in result.items():
        print(f"{coin} coin: {count}", flush=True)
    print(f"Execution time: {execution_time:.8f} seconds", flush=True)
    print("_______________________________________", flush=True)

#Program #1 (b)

import time

print("_________Greedy List Not Sorted________")

class MakingChange:
    def __init__(self):
        # Hardcoded denominations
        self.denominations = [1 , 0.1, 5, 2, 0.5, 0.05, 0.02]

    def make_change(self, amount):
        change = {}
        for coin in self.denominations:
            if amount >= coin:
                count = int(amount // coin)
                change[coin] = count
                amount = round(amount - (coin * count), 2)
        return change

# Directly instantiate MakingChange instead of using a factory
change_maker = MakingChange()

# Define test cases
test_cases = [1.25, 8.72, 12.35]

# Run each test case and measure execution time
for amount_to_change in test_cases:
    start_time = time.perf_counter()  # Start timing with high precision
    result = change_maker.make_change(amount_to_change)
    end_time = time.perf_counter()    # End timing with high precision
    execution_time = end_time - start_time

    print(f"Change for {amount_to_change} is:", flush=True)
    for coin, count in result.items():
        print(f"{coin} coin: {count}", flush=True)
    print(f"Execution time: {execution_time:.8f} seconds", flush=True)
    print("_______________________________________", flush=True)

"""# **Program #2**"""

# Program #2

import time

class MakingChangeExhaustive:
    def __init__(self):
        # Denominations (hard-coded)
        self.denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
        self.solution_count = 0  # To count the number of solutions

    def find_all_solutions(self, amount, index=0, current_combination=None):
        if current_combination is None:
            current_combination = []

        # If amount is zero, a valid combination is found
        if amount == 0:
            print(self.to_string(current_combination))  # Print solution
            self.solution_count += 1  # Increment the solution count
            return

        # If the amount becomes negative or we've gone through all denominations, stop
        if amount < 0 or index >= len(self.denominations):
            return

        # Recursively try two scenarios: including or excluding the current denomination
        coin = self.denominations[index]

        # Include the current denomination and recurse
        current_combination.append(coin)
        self.find_all_solutions(round(amount - coin, 2), index, current_combination)
        current_combination.pop()  # Backtrack

        # Exclude the current denomination and move to the next denomination
        self.find_all_solutions(amount, index + 1, current_combination)

    def to_string(self, combination):
        # Format the combination in a readable way
        return " + ".join([str(coin) for coin in combination])

# Main execution
if __name__ == "__main__":
    change_calculator = MakingChangeExhaustive()

    # Example amount to find all solutions
    amount_to_change = 12.35
    print(f"All solutions for making change for {amount_to_change} are:")

    # Start timing
    start_time = time.perf_counter()

    # Redirect output to a file
    import sys
    with open("solutions_test_output.txt", "w") as f:
        sys.stdout = f  # Redirect output to the file
        change_calculator.find_all_solutions(amount_to_change)
        sys.stdout = sys.__stdout__  # Reset output back to the console

    # End timing
    end_time = time.perf_counter()
    execution_time = end_time - start_time

    # Print results summary
    print("Results have been written to solutions_test_output.txt")
    print(f"Execution time: {execution_time:.8f} seconds")
    print(f"Total solutions found: {change_calculator.solution_count}")

from collections import Counter, defaultdict

def find_change_dp(denominations, amount):
    # Convert to cents to avoid floating point issues
    amount = int(round(amount * 100))
    denominations = [int(round(coin * 100)) for coin in denominations]

    # DP table to store the number of ways to make change
    dp = defaultdict(list)
    dp[0] = [[]]  # Base case: one way to make zero amount (no coins)

    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                dp[current_amount].append(solution + [coin])

    # Convert solutions back to original coin values
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

all_solutions = find_change_dp(denominations, amount)

# Print all solutions and their counts
print("All Possible Solutions:")
for idx, solution in enumerate(all_solutions, 1):
    coin_counts = Counter(solution)
    print(f"Solution {idx}:")
    for coin, count in coin_counts.items():
        coin_label = "coin" if count == 1 else "coins"
        print(f"{count} {coin_label} of {coin}")
    print()

print(f"Total Number of Solutions: {len(all_solutions)}")

print(f"Total Number of Solutions: {len(all_solutions)}")

#Program #2 rerusion
import csv
from collections import Counter, defaultdict
from datetime import datetime

def find_change_dp(denominations, amount):
    # Convert to cents to avoid floating point issues
    amount = int(round(amount * 100))
    denominations = [int(round(coin * 100)) for coin in denominations]

    # DP table to store the number of ways to make change
    dp = defaultdict(list)
    dp[0] = [[]]  # Base case: one way to make zero amount (no coins)

    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                dp[current_amount].append(solution + [coin])

    # Convert solutions back to original coin values
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

# Measure execution time
start_time = datetime.now()
all_solutions = find_change_dp(denominations, amount)
end_time = datetime.now()
execution_time = (end_time - start_time).total_seconds()

# Set filename to "AllTheSolutionsTest1.txt"
filename = "AllTheSolutionsTest1.txt"

# Write all solutions to the TXT file
with open(filename, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Solution Number", "Coins Used"])
    for idx, solution in enumerate(all_solutions, 1):
        writer.writerow([idx, ", ".join(map(str, solution))])

# Print the number of solutions and total execution time
print(f"Total Number of Solutions: {len(all_solutions)}")
print(f"Time of Execution: {execution_time:.2f} seconds")
print(f"Solutions have been saved to {filename}")

#Program #2bis
import csv
from collections import defaultdict
from datetime import datetime

def find_change_dp_reversed(denominations, amount):
    # Convert to cents to avoid floating point issues
    amount = int(round(amount * 100))
    # Sort denominations in descending order for prioritizing maximum units
    denominations = sorted([int(round(coin * 100)) for coin in denominations], reverse=True)

    # DP table to store the number of ways to make change
    dp = defaultdict(list)
    dp[0] = [[]]  # Base case: one way to make zero amount (no coins)

    # Process denominations to maximize the count of larger coins first
    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                # Add new solutions to maximize usage of the current coin
                dp[current_amount].append(solution + [coin])

    # Convert solutions back to original coin values
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

# Measure execution time
start_time = datetime.now()
all_solutions = find_change_dp_reversed(denominations, amount)
end_time = datetime.now()
execution_time = (end_time - start_time).total_seconds()

# Set filename to "AllTheSolutionsTest2.txt"
filename = "AllTheSolutionsTest2.txt"

# Write all solutions to the TXT file
with open(filename, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Solution Number", "Coins Used"])
    for idx, solution in enumerate(all_solutions, 1):
        writer.writerow([idx, ", ".join(map(str, solution))])

# Print the number of solutions and total execution time
print(f"Total Number of Solutions: {len(all_solutions)}")
print(f"Time of Execution: {execution_time:.2f} seconds")
print(f"Solutions have been saved to {filename}")



"""# **Program #3**"""

import csv
from collections import defaultdict
from datetime import datetime

def find_change_dp_ordered(denominations, amount):
    # Convert to cents to avoid floating point issues
    amount = int(round(amount * 100))
    # Convert denominations to cents and keep them in ascending order for consistent ordering
    denominations = sorted([int(round(coin * 100)) for coin in denominations])

    # DP table to store solutions in a 2D array (list of lists)
    dp = defaultdict(list)
    dp[0] = [[]]  # Base case: one way to make zero amount (no coins)

    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                dp[current_amount].append(solution + [coin])

    # Convert solutions back to original coin values and return the ordered list of solutions
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

# Measure execution time
start_time = datetime.now()
all_solutions = find_change_dp_ordered(denominations, amount)
end_time = datetime.now()
execution_time = (end_time - start_time).total_seconds()

# Set filename to "AllTheSolutionsTest3.txt"
filename = "AllTheSolutionsTest3.txt"

# Write all solutions to the TXT file without immediate display
with open(filename, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Solution Number", "Coins Used"])
    for idx, solution in enumerate(all_solutions, 1):
        writer.writerow([idx, ", ".join(map(str, solution))])

# Load and compare with CORRECT_<filename>.txt file to validate
correct_filename = "CORRECT_AllTheSolutionsTest3.txt"
try:
    with open(correct_filename, mode='r') as correct_file:
        correct_solutions = correct_file.readlines()

    with open(filename, mode='r') as generated_file:
        generated_solutions = generated_file.readlines()

    if correct_solutions == generated_solutions:
        print("The generated solutions match the contents of the CORRECT file.")
    else:
        print("The generated solutions differ from the CORRECT file.")

except FileNotFoundError:
    print(f"Could not find the comparison file: {correct_filename}.")
    print("Please ensure it is available for comparison.")

# Print the number of solutions and total execution time
print(f"Total Number of Solutions: {len(all_solutions)}")
print(f"Time of Execution: {execution_time:.2f} seconds")
print(f"Solutions have been saved to {filename}")

"""# **Program #4**"""

import csv
from collections import defaultdict
from datetime import datetime

def find_change_dp_with_cost(denominations, amount):
    # Convert to cents to avoid floating point issues
    amount = int(round(amount * 100))
    # Convert denominations to cents
    denominations = [int(round(coin * 100)) for coin in denominations]

    # DP table to store solutions
    dp = defaultdict(list)
    dp[0] = [[]]  # Base case: one way to make zero amount (no coins)

    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                dp[current_amount].append(solution + [coin])

    # Convert solutions back to original coin values and calculate cost
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Function to evaluate solution costs and trace improvements
def evaluate_and_trace_best_solution(denominations, amount):
    # Find all possible solutions
    all_solutions = find_change_dp_with_cost(denominations, amount)

    # Set up trace file
    trace_filename = "CORRECT_SolutionsWhichImproveIncrementally.txt"
    with open(trace_filename, mode='w', newline='') as trace_file:
        trace_writer = csv.writer(trace_file)
        trace_writer.writerow(["Improvement Step", "Cost (Number of Coins)", "Coins Used"])

        # Initialize variables to track the best solution
        best_solution = None
        best_cost = float('inf')
        improvement_step = 0

        # Iterate through solutions, evaluate cost, and trace improvements
        for solution in all_solutions:
            cost = len(solution)  # Cost is based on the number of coins (units)

            # Check if this solution has a lower cost than the current best
            if cost < best_cost:
                best_cost = cost
                best_solution = solution
                improvement_step += 1  # Increment improvement step
                # Record this improved solution in the trace file
                trace_writer.writerow([improvement_step, best_cost, ", ".join(map(str, best_solution))])

    # Return the best solution found and its cost
    return best_solution, best_cost

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

# Measure execution time
start_time = datetime.now()
best_solution, best_cost = evaluate_and_trace_best_solution(denominations, amount)
end_time = datetime.now()
execution_time = (end_time - start_time).total_seconds()

# Print final best solution and cost, and execution time
print(f"Best Solution: {best_solution}")
print(f"Minimum Cost (Number of Coins): {best_cost}")
print(f"Time of Execution: {execution_time:.2f} seconds")
print(f"Trace of improvements saved to CORRECT_SolutionsWhichImproveIncrementally.txt")

"""# **Program #5**"""

import csv
from collections import defaultdict
from datetime import datetime

def find_change_dp_with_cost(denominations, amount):
    amount = int(round(amount * 100))  # Convert to cents
    denominations = [int(round(coin * 100)) for coin in denominations]  # Convert denominations to cents

    # DP table to store all possible solutions
    dp = defaultdict(list)
    dp[0] = [[]]

    for coin in denominations:
        for current_amount in range(coin, amount + 1):
            for solution in dp[current_amount - coin]:
                dp[current_amount].append(solution + [coin])

    # Return all possible solutions for the amount
    all_solutions = [[coin / 100 for coin in solution] for solution in dp[amount]]
    return all_solutions

# Prg5 Function: Store Best Calculated Solution and Evaluate Time Savings
def evaluate_and_store_best_solution(denominations, amount):
    all_solutions = find_change_dp_with_cost(denominations, amount)

    # Initialize variables
    best_solution = None
    best_cost = float('inf')
    solution_table = []

    # Start time measurement
    start_time = datetime.now()

    # Iterate through solutions to find the best one
    for solution in all_solutions:
        cost = len(solution)
        if cost < best_cost:
            best_cost = cost
            best_solution = solution
            # Store the best solution
            solution_table.append((best_cost, best_solution))

    # End time measurement
    end_time = datetime.now()
    execution_time = (end_time - start_time).total_seconds()

    # Return the best solution, its cost, and execution time
    return best_solution, best_cost, execution_time, solution_table

# Example usage
denominations = [5, 2, 1, 0.5, 0.2, 0.1, 0.05]
amount = 12.35

# Call Prg5 function
best_solution, best_cost, execution_time, solution_table = evaluate_and_store_best_solution(denominations, amount)

# Print results
print(f"Best Solution: {best_solution}")
print(f"Minimum Cost (Number of Coins): {best_cost}")
print(f"Time of Execution: {execution_time:.2f} seconds")
print("Solution Table:", solution_table)

"""# **Program #6**"""

def find_change_with_cut(denominations, amount):
    amount = int(round(amount * 100))  # Convert to cents
    denominations = [int(round(coin * 100)) for coin in denominations]

    # Variables to track the best solution and its cost
    best_solution = None
    best_cost = float('inf')

    # Function to perform recursive search with cut
    def search(current_amount, solution, cost):
        nonlocal best_solution, best_cost
        if current_amount == 0:
            if cost < best_cost:
                best_cost = cost
                best_solution = solution[:]
            return
        if cost >= best_cost:  # Implement the cut
            return

        for coin in denominations:
            if current_amount >= coin:
                solution.append(coin / 100)
                search(current_amount - coin, solution, cost + 1)
                solution.pop()

    # Start time measurement
    start_time = datetime.now()

    # Start recursive search
    search(amount, [], 0)

    # End time measurement
    end_time = datetime.now()
    execution_time = (end_time - start_time).total_seconds()

    # Return the best solution found, its cost, and execution time
    return best_solution, best_cost, execution_time

# Example usage for Prg6
best_solution, best_cost, execution_time = find_change_with_cut(denominations, amount)

# Print results
print(f"Best Solution with Cut: {best_solution}")
print(f"Minimum Cost (Number of Coins): {best_cost}")
print(f"Time of Execution with Cut: {execution_time:.2f} seconds")

"""## Program 6bis

Sorting denominations before applying the cut can enhance performance by allowing the cut to be more effective, saving computation time and resources.
"""

# Measure performance with unsorted denominations
start_time_unsorted = time.time()
_, _, call_count_unsorted = find_change_with_cut(denominations, amount)
execution_time_unsorted = time.time() - start_time_unsorted

# Measure performance with sorted denominations (descending order)
denominations_sorted = sorted(denominations, reverse=True)
start_time_sorted = time.time()
_, _, call_count_sorted = find_change_with_cut(denominations_sorted, amount)
execution_time_sorted = time.time() - start_time_sorted

# Display comparison results
print("Unsorted Denominations:")
print(f"Execution Time: {execution_time_unsorted:.4f} seconds")
print(f"Number of Recursive Calls: {call_count_unsorted}")

print("\nSorted Denominations:")
print(f"Execution Time: {execution_time_sorted:.4f} seconds")
print(f"Number of Recursive Calls: {call_count_sorted}")

"""#**Program #7**"""

#Program 7: Calculating a Sorted Subset of the 4 Best Solutions

def find_top_4_solutions(denominations, amount):
    # Generate all solutions
    all_solutions = find_change_dp_with_cost(denominations, amount)

    # Sort solutions based on the cost (number of coins)
    sorted_solutions = sorted(all_solutions, key=len)

    # Get the top 4 solutions
    top_4_solutions = sorted_solutions[:4]

    return top_4_solutions

# Example usage
top_4_solutions = find_top_4_solutions(denominations, amount)
print("Top 4 Best Solutions (Sorted by Cost):")
for idx, solution in enumerate(top_4_solutions, 1):
    print(f"{idx}: {solution} (Cost: {len(solution)} coins)")

#Program 7’: Calculating the Best and Two "Less Worst" Solutions
def find_best_and_less_worst_solutions(denominations, amount):
    # Best solution for the original amount
    all_solutions = find_change_dp_with_cost(denominations, amount)
    best_solution = all_solutions[0] if all_solutions else None

    # Adjust the amount slightly for the less worst solutions
    step_size = min(denominations)  # Use the smallest denomination as step size
    slightly_higher_amount = amount + step_size
    slightly_lower_amount = amount - step_size

    # Find solutions for the adjusted amounts and check if they exist
    higher_solution_list = find_change_dp_with_cost(denominations, slightly_higher_amount)
    lower_solution_list = find_change_dp_with_cost(denominations, slightly_lower_amount)

    higher_solution = higher_solution_list[0] if higher_solution_list else None
    lower_solution = lower_solution_list[0] if lower_solution_list else None

    return best_solution, higher_solution, lower_solution

# Example usage
best_solution, higher_solution, lower_solution = find_best_and_less_worst_solutions(denominations, amount)

print("Best Solution:", best_solution or "No solution found")
print("First Less Worst (Slightly Higher Amount):", higher_solution or "No solution found")
print("Second Less Worst (Slightly Lower Amount):", lower_solution or "No solution found")

"""# **Graph Relationship part**"""

def is_transitive(R):
    n = len(R)  # Number of rows/columns in the square matrix
    # Iterate through all pairs (i, j) and check the transitivity condition
    for i in range(n):
        for j in range(n):
            if R[i][j] == 1:  # If R[i][j] is 1, check for transitivity
                for k in range(n):
                    if R[j][k] == 1 and R[i][k] != 1:  # If R[j][k] is 1 but R[i][k] is not 1, it's not transitive
                        return False  # Immediately return False if not transitive
    return True  # Return True if the relation is transitive


# Example relation matrix
R = [
    [1, 1, 1],
    [0, 0, 1],
    [0, 0, 1]
]

# Check and print whether the relation is transitive
if is_transitive(R):
    print("The relation is transitive.")
else:
    print("The relation is NOT transitive.")